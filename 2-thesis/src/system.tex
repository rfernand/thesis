
In this chapter we will describe the different parts of the system and how the
identification protocols will work.
%In this section we describe the user identification system. 
%This system provides a distributed and secure way to attain a user-password
%identification scheme like the ones commonly seen in centralized services.

\section{Architectural principles}

\subsection{Securing the nodes of a leafset}

%% Refering to the section in the paper "A Scalable Architecture for Highly Reliable Certification"
The first step to requesting a service is to acquire the set of nodes that
compose the leafset for a given root key $K$. Supposing that $K$ is associated
with node $K_{ROOT}$, there remains a probability for $K_{ROOT}$ to be
malicious. $K_{ROOT}$ might lie and provide references to other malicious nodes
in order to collude against the requester, or it might deny any service by
remaining silent. Therefore, a simple request to $K_{ROOT}$ will not suffice to
acquire a reliable leafset associated with $K$.

Our solution for mitigating this issue is to use the DiversityTrustedRoute
algorithm~\cite{diversity_trusted_route}. DiversityTrustedRoute uses different
nodes as starting points in order to reach the same root node $K_{ROOT}$. The
diversity of the routing tables on each node guarantees a very high probability
of reaching root node $K_{ROOT}$ using different paths, and therefore of
entering the leafset of $K_{ROOT}$ via different nodes. This makes for a more
secure way of acquiring the leafset associated with a key $K$.

\subsection{Normal service request}

Based on the services seen on~\cite{p2p_certification}, to find the nodes associated with a given
service, node $A$ computes the hash
of the service name: $K_s = SHA(ServiceName)$. Let $S_{root} $ be the node that
is closest to $K_s$ in the DHT. $A$ uses DiversityTrustedRoute to acquire the
leafset of $S_{root}$. $A$ thus obtains access to the set $S$ of nodes that
process requests for service $ServiceName$. Let $L$ be the number of nodes in a
leafset: $card(S) = L + 1$.

Once $A$ has acquired $S$, it proceeds to the inception of its service request
by sending a $RequestInit$ message to every node in $S$. A $RequestInit$
message contains a public key $A^{pub}$ of client $A$. In reply to such a
message, every node $S_i$ sends its own public key $S^{pub}_i$. In order to
avoid man-in-the-middle attack, all the ensuing communications between $A$ and
nodes that belong to $S$ will use a public/private key encryption scheme to
ensure that no other node can read the content of the messages.
% later the node will use his user private key & public key in this exchange

If $A$ receives at least $\frac{L}{2} + 1$ answers from the nodes in $S$, then
$A$ considers that the transaction will proceed. Since $S$ is composed of
common nodes from the DHT, it is possible for some of these nodes to be
malicious. However, as explained in our evaluation of the quasi identification
protocol~\ref{sec:evaluation}, a situation where $S$ contains more than
$\frac{L}{2}$ malicious nodes is highly improbable.

A combination of network failures and/or malicious nodes that choose to remain
silent may prevent $A$ from receiving at least $\frac{L}{2} + 1$ answers. Since
$S$ retains the properties of Pastry's leafset, the numerical closeness of its
nodes in the DHT implies that they will very likely be geographically far on
the Internet. Therefore, the probability of $\frac{L}{2} + 1 $ simultaneous IP
routing failures or node failures, that is the probability for more than
$\frac{L}{2}$ answers to not reach $A$, is very close to zero. To account for
this type of situation, $A$ aborts the transaction if it has not received a
sufficient amount of identical answers after a timeout $\delta t$. this is a
very rare and highly improbable case, as shown by our evaluation
in~\ref{sec:evaluation}.


\subsection{Challenges and computational puzzles}
\label{sec:challenges_puzzles}
A challenge or computational puzzle involve a node $X$ posing a challenge to
$A$ that requires a large amount of computation to solve, but is easy to verify
by the node $X$ that sent the challenge. The idea behind the use of
computational puzzles is to restrict the abuse of certain operations in the
system, making them costly enough to make an attack unfeasible under normal
circumstances, but computationally affordable for normal operations of a node
in the system. As an example, in Borisov et al.~\cite{borisov2006computational} described a
fully decentralized mechanism based on computational puzzles for structured P2P
overlays. The following system only needs a challenge that fulfill the
criteria of a computational puzzle, so any kind of puzzle that fits can be chosen for
that purpose.

\subsection{User Identification Service}
\label{sec:identificators}
%%% more message costly version:
%%A set of $N$ nodes $I_1, I_2, \cdots, I_{N}$ manage the user information
%%needed for his identification.
%%The node ID of the identificator $i$ of the user $U$ with username $username$ is
%%obtained by the function $I_i = SHA^{i}(username)$.
%%The identificators $I_i$ of the username $username$ forms the identification service $I$ for the user with username $username$.
%%Each identificator $I_i$ administers a number of $L$ replicas of the user information. In Pastry,
%%the replicas are stored in the leafset of each node, while in Chord the $r$
%%successors of each node are used.

Every user registered has a set $I$ of nodes that
will constitute the quasi-secure identification authority for the
identification service.
To determine which  nodes belong to $I$, a node computes its key $K$ such that
$K = SHA(U^{username} \bigoplus SHA(U^{username}))$. 

$I_{root}$ is the node closest to $K$ in the DHT, and the quasi-secure identification authority $I =
{I_1, I_2, \cdots, I_{L+1}}$ for the identification of the user with the
username $username$ is composed of $I_{root}$ and of its leafset secured
through DiversityTrustedRoute. These nodes are called identificators of the
user $U$ with username $username$.

 In order to prevent man-in-the-middle attack, we use an asymmetric key
encryption scheme for the communications between a node $A$ and $I$. This
induces that every node in $I$ must exchange public keys with every node that
makes a request for the user information. The initial cost expressed in number
of messages is $2(L+1)$, but this exchange only occurs the first time a
node $A$ requests the user identification service from $I$, as the node $A$
maintains a local cache with the public keys of the nodes $I_i \in I$. Also,
every node $I_i \in I$ maintains a local cache with the public keys of ${I_1,
I_2, \cdots, I_{L+1}}$, and key exchanges only occur again if a new node
replaces one of the original nodes from $I$.

%%%%%%% ---- OLD, NOT APPLICABLE TODAY ----
%%%The general view of the system consists in a multi-layered network based in trusted rings.
%%The general view of the system consists in a double-layered network; a Trusted
%%ring of nodes nested inside a normal DHT, with multiple routing policies
%%depending in the protocol of differents services. The user registration,
%%sign-in, logout and password change operations respectively allow a node to
%%register an user identity, to identify himself with an existing user identity,
%%to remove your user session and to change the password used to sign-in.
%%
%%The system needs to have a \textit{trusted ring} maintained by periodical
%%checks of capacity of his members to remain in the trusted ring and a
%%reputation system to evaluate this. Also, similar to the
%%leafset concept in Pastry, each trusted node needs to maintain a
%%\textit{trustset}, which basically consist in D numerically closest trusted
%%nodes with D/2 clockwise nodes, and D/2 counter-clockwise ones.
%%
%%The system used to build the trusted node infraestructure in the P2P networks
%%needs to regularly asses the ability of the nodes to be part of the trusted
%%ring.
%%
%%The figure shows a basic structure of the system. There are normal nodes and
%%trusted nodes. Every trusted nodes maintains a \textit{trustsets}.

\subsection{Lazy User's Information Store Maintenance}
\label{sec:lazy_node_maintenance}
Insertions and departures of nodes in the DHT cause modifications of the
leafsets, and it is therefore crucial to maintain the consistency of the user's
information $S_{username}$ used for his identification procedures. The user's information
consists in the user's public keys and salt. This has to be done on every node in the identification service
$I$.\\

Upon entering a leafset, a node $X$ must update its own view of the user's
information. Analog to the lazy log consistency maintenance procedure seen
in~\cite{p2p_certification}, it starts by following the steps below to find
which user's information store must be updated.\\

\textit{Step 1:} $X$ constructs the set of nodes
$N = \{ X_{-L/2}, X_{-L/2 +1}, \cdots, X, \cdots X_{L/2 -1}, X_{L/2} $
composed of its leafset, and of the $\frac{L}{2} +1$ nodes both on the right
side and on the left of its leafset. 
%% TODO: figure example  of this
In order to build this set of nodes, $X$ can ask the farthest nodes $X_{-L/2}$
and $X_{L/2}$ of its leafset for their own respective leafsets. If one of these
nodes fails to answer in a timely manner, $X$ can ask the second to farthest
node, and so on until its immediate neighbors in the leafset. Having
$\frac{L}{2} +1$ malicious neighbors on both sides is highly improbable, and
practically unfeasible: for more details about this statement, please refer to
our probabilistic evaluation in section~\eqref{sec:eval_lazy_maintenance}. \\

\textit{Step 2:} $X$ computes interval $L$ such that
$$
L = [ X_{-L/2} - \frac{| X_{-L/2} - X_{-L/2 +1} |}{2}, X_{L/2} +\frac{|
X_{L/2} - X_{L/2 -1} |}{2} ]
$$


and sends it to every node in set $N$. Upon reception of this message, every
node replies with a set of all the usernames $U^{username} \in L$ it
stores, along with the last information regarding the user's
information corresponding to each username. Thus the format of a response is a
variable-size set of pairs $\{ U^{username}, S_{username}\}$.\\


\textit{Step 3:} $X$ builds set 
$Y =  \{ \{U^{username_i}, S_{username_i}\},\cdots,\{ U^{username_j},
S_{username_j}\} \} $ the union of all received usernames and user's
information. $X$ then discards all pairs $\{ U^{username}, S_{username}\}$ that
appear less than $\frac{L}{2} +1$ times in $Y$, since these may have been
generated by colluding nodes. Once this is done, $X$ synchronizes all the
user's information store whose username matches one of the remaining usernames
in set $Y$.\\

% checkpoints -> not used in this implementation
%For every file of user information that $X$ must synchronize, $X$ selects a node $Z$ in $N$ that
%holds this user information. If $X$ does not have any entry for this username,
%then $X$ must ask $Z$ for the entire user's information store. Otherwise, $X$
%sends the last $q$ public keys and salts it has of the user.

It is essential for $X$ to handle the synchronization as an atomic operation,
as responding to a change password request while the user information is not up
to date may lead to problems in further requests. Therefore, $X$ postpones all
transactions about the user information until the synchronization is over.


\subsection{Node Failures and Node Departures}
\label{sec:node_failures_and_departures}
Two situations call for the removal of a node. A normal departure corresponds
to an honest node that notifies its departure to the nodes of its leafset. In a
crash departure situation, the node fails silently. Pastry exchanges
periodical heartbeats among nodes in the same leafset in order to detect such
failures.\\

Upon removal of a peer in its leafset, a node $X$ will look for a replacement.
$X$ starts by identifying which side of its leafset it must fix: the left side
or the right side, depending on the nodeId of the node that was removed. Let $N
= {N_{\alpha}, N_{\beta}, \cdots, N_{\omega}}$ be the set of $\frac{L}{2} - 1$
nodes corresponding to the side of the leafset in need of fixing. In order to
find the next node to add to its leafset, $X$ request the leafset of the
farthest node $N_{\omega}$ in set $N$. Upon reception of the answer, $X$ then
inserts in its own leafset the reference to the node closest to $N_{\omega}$
that does not yet belong to $N$. If $N_{\omega}$ remains silent, $X$ must
repeat the operation with the second to farthest node in $N$, and so on until
reaching node $N_{\alpha}$ if no timely answer ever comes back. If $X$ fails to
receive any answer from the nodes in its leafset, then it cannot repair its
leafset.\\

Once it has successfully fixed its leafset, $X$ must synchronize its user's
information. $X$
uses DiversityTrustedRoute to acquire the leafset of the node it has just
added. $X$ then synchronizes its stored user's information with the nodes in
the acquired leafset by means of the scheme described in~\ref{sec:lazy_node_maintenance}.


\section{System Protocols}
We now describe our protocols based on the system model. 
%Figure 2 shows the information objects and
%their storage locations, with arrows for the abstract flow of the
%login procedure, Table I lists the terms used in the algorithms.
%A. Account Registration

\subsection{Account registration}
\includegraphics[width=14cm]{../img/registration_protocol_mockup.png}\\

To register a new user account ($U$), the node first
has to choose a \textit{username} and a \textit{password}.
%The \textit{username} should be unique in the network.
% The user checks if the username exists by sending a
% REGISTER(username, identity_file: [[c(user_keys_file), salt]).
% This operation use a accounted routing algorithm that uses only trusted
% nodes. When the register operation reaches the closest node to the username,
% it propagates a TRUSTSET_USERNAME_REGISTRATION operation. This operation sends a
% call to each node in the trustset of the node, which then pass to do a council
% meeting. If the meeting results in favor, each of them sends a
% OK_USERNAME_REGISTRATION(user_identity_file_name) to node doing the REGISTER operation.
% 
% DETAILS OF THE REGISTER OPERATION
% DETAILS OF THE COUNCIL MEETING --> Explain before, in trusted node part 
% 

% key store file
Then, a key derivation process is issued to generate the user Private and
Public Keys. The
key derivation utilizes a Salt ($U^{salt}$) and a Password ($U^{password}$) to
obtain the user's private and public Keys
($U^{priv}$ and $U^{pub}$).
The node  looks for the set $I$ set of nodes that will constitute the
identification service for the user $U$. To obtain the list of nodes that provides the user identification service for
the username $U^{username}$, the node $A$ computes its key $K$ such that $K =
SHA(U^{username})$. 

Then the node $A$ sends a request to every node $I_i$ in $I$ to register the
$U^{salt}$ and $U^{Pub}$ under the chosen  username  $U^{username}$.

Each node in $I$ agrees in generating a random challenge~\ref{sec:challenges_puzzles}, which is then sent to the
client $A$ by every node $I_i \in I$ using the node public key to encrypt the
message.

If the node $A$ succeeds in answering correctly to the challenge, each node $I_i \in I$ then sends a user registration confirmation message to all nodes
in $I$ containing the new user public key and salt. If a node $I_i$ receives at
least $\frac{L}{2} + 1$ identical user registration confirmation messages from
the others nodes in $I$, it sends a affirmative answer to the node $A$.

When the node
$A$ receives at least $\frac{L}{2} + 1$ identical affirmative answers from
$I$ regarding the user registration, then $A$ assumes that the user was
actually registered.

%unique username
In case that the username was taken,
the node $A$ is prompted for a new username.



\subsection{User private key recovery}
\label{sec:private_key_recovery}
\includegraphics[width=14cm]{../img/login_protocol_mockup}\\

First, the node $A$ looks for the set $I$ set of nodes that will constitute the
identification service for the user $U$.
To obtain the list of nodes $I$ that provides the user identification service for
the username $U^{username}$, the node $A$ computes its key $K$ such that $K =
SHA(U^{username})$. 
Then the node $A$ sends a request to every node $I_i$ in $I$ to obtain the user
salt $U^{salt}$ needed to derive the user private key $U^{priv}$.
 When the node $A$ receives at least $\frac{L}{2} + 1$ identical affirmative answers from
$I$ regarding the user salt, then $A$ assumes that the salt retrieved
corresponds to the one registered previously by the user ($U^{salt}$). Finally,
the node proceeds to derive the user private key $U^{priv}$ using his user password $U^{password}$.

\subsection{User Sign-in}
\includegraphics[width=14cm]{../img/session_creation_protocol_mockup}\\

Before carrying out a transaction for a client $A$, $S$ proceeds to
verify the identity of the client from another set $I$ of nodes. At the end of
the identification process, the objective is to return a session key to $A$
and to store the created session on the nodes that belong $S$.

Each node in $S$ agrees in generating a random challenge~\ref{sec:challenges_puzzles}, which is then sent to the
client $A$ by every node $S_i \in S$ using the user public key to encrypt the
message.

Then, client $A$ responds each request with the corresponding answer to the
challenge encrypted with his user private key $U^{priv}$, generating
$E^{challenge}_{U^{priv}}$. 

Upon reception of the $E^{secret_i}_{U^{priv}}$ message from the client $A$, every node in $S$
starts looking for the set $I$ of nodes that will constitute the quasi
identification authority. As seen in user identification service~\ref{sec:user_identificators}, to
determine which nodes belong to $I$, $S$ computes
its key $K$ such that $K = SHA(U^{username})$.

Then each node in $S$ sends a request to every node $I_i$ in $I$ asking for the Username public key $U^{pub}$. When a node
$S_i$ of $S$ receives at least $\frac{L}{2} + 1$ identical answers from
$I$ regarding the $U^{pub}$, then $S_i$ assumes that the public key received
actually corresponds to the Username being identified. Each node $S_i$ in $S$
uses the $U^{pub}$ to decrypt $E^{secret_i}_{U^{priv}}$. If the result matches
the shared random secret $S^{secret}_i$, $S_i$ recognizes the node $A$ as the
user $U$.
Lastly, each node in $S$ agrees in the generation of the sessions keys for the
node $A$, which is then sent to the client $A$ by every node $S_i \in S$ using
the user public key to encrypt it. The session keys are stored in the
nodes that belong to $S$.

\subsection{Logout}
The session are maintained by each service the user identified with. To close a
session, the node identified as the user $U$ sends a session close request to
the service $S$ using the session keys for the transaction. Also, the sessions
keys are issued for a certain time. After that time is passed, the node needs
to ask for a new session key with the service.


\subsection{Password Change}

First, the node $A$ needs to recover his actual private key using the process
in~\ref{sec:private_key_recovery}. Then the node $A$ generates a new private/public
key pair using the new password.  With this, the node $A$ request a
password change to every node $I_i$ in $I$. The request is signed with the
actual user private keys, and includes the new user public key $U^{pub}_{new}$
and salt used to derive his new private key $U^{salt}_{new}$. 
Each node $I_i \in I$ then sends a password change confirmation message to all nodes
in $I$ containing the new user public key and salt. If a node $I_i$ receives at
least $\frac{L}{2} + 1$ identical password change confirmation messages from
the others nodes in $I$, it sends a affirmative answer to the node $A$.
 When the node $A$ receives at least $\frac{L}{2} + 1$ identical affirmative
answers from $I$ regarding the user password change, then $A$ assumes that the
user keys (and password) were updated.

