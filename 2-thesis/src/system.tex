Existing systems for the user identification in P2P networks only consider the
use of preshared keys to identificate the user in the network. While that can
be easily implemented, does not provide to the users the flexibility that a
username-password based identification provides when using different devices to
log in in the system. As the user needs to transfer manually his keys from one
device to another, there are many security issues when they are handled without
care or the devices (like a cellphone) are lost. 

The use of a username and a password means that the user keys needs to: a) be
secured inside the identification system or b) be derived from information
stored in the identification system. Between  the two options, the first one
needs a trusted storing scheme with additional use of encryption to secure the
private keys. In the other hand deriving the user private keys let us build the
identification system with the same desired properties without adding
additional complexity.

To handle the user keys without compromising the users identity, aditional
security layers needs to be placed inside the P2P network.

To secure the stored keys, the proposed system uses encryption, indirection and
rings of trust inside the network. The system goal is to offer a secure mean to
identify an user using only his username/password knowledge taking in
consideration the precense of bizantine nodes.

As shown in \cite{the_sybil_attack}, it is impossible to get a 100\% reliable
system over a DHT where malicious nodes are present. The goal of our approach
is to reduce drastically the probability of a malicious node to impersonate
another user using the identification system.
%While the probability can always exist, it should be highly unlikely to happen.

In this chapter we will describe the different parts of the system and how the
identification algorithms will work.
%In this section we describe the user identification system. 
%This system provides a distributed and secure way to attain a user-password
%identification scheme like the ones commonly seen in centralized services.


\section{Building blocks and notation}

For simplicity, we assume in the following that the underlyng DHT is
Pastry~\cite{pastry} seen in the section~\ref{sec:pastry}. We suppose that
every node in the DHT self-generates its own pair of public and privates keys
($X^{pub}$, $X^{priv}$) to be used with an asymmetrical encryption
algorithm~\cite{asymmetrical_encryption_algorithm}. The size of the keys used
in the whole system is both fixed and large enough to make it computationally
infeasible to decrypt an information without knowing the corresponging private
keys. We will assume that an User is identified by the criptographic proof of
his private key. 

SHA stands for the Secure Hash Algorithm One (SHA-1 - 160 bits hash). We also
assume that all communications among nodes are made using the TCP protocol, and
that all transmissions errors are handled at the transport level.

A simple storage system is needed.
%% TODO:
%The \textit{trustsets} are in charge of the storage of the user keys that are
%used to identify an user in the system. The system needs a PUT(key,
%file) operation that stores the file in the closest trusted node based in the
%routing algorithm and a GET(key) operation that retrieves the stored file.


%%The identification system needs to use 


%% -- THIS IS NOT NECESSARY FOR THE IDENTIFICATION SYSTEM YET IT CAN BE USEFULL --
% Our final assumption is that the underlying operating system of every node which
%participates to the DHT is running the Network Time Protocol. Thus, we consider
%that every node has a good global time, wiuth a small deviation from the
%Coordinated Universal Time (UTC)

%\section{Securing  P2P networks}

\section{A Quasi-Identification Service}

% definition of a node and a service that is going to identify with it

Let A be a node of the DHT, and $S = \{S_1, S_2, \cdots, S_n\}$ a set of $n$
nodes that cooperate to provide a service. Let $NameofS$ be the name of service
$S$; every node that needs to use the service knows $NameofS$. $K_s =
SHA(NameofS)$ is the key that identifies $S$ in DHT, and $S_{root}$ is the node
closest to $K_s$ in the DHT. It follows that $S = \{S_1, S-2, \cdots, S_n\}$ is
composed of node $S_{root}$ and of all the nodes in its leafset. Let $I$ be a
identification service such that $I = \{ I_1, I_2, \cdots, I_n\}$ is a group of
$n$ nodes belonging to the DHT. 

% interaction between A, S & I, Figure and such

We suppose that the number of nodes that compose a service $S$ is fixed and does
not change over time. We also suppose that the same stands for any
quasi-identification service $I$.



% normal p2p networks provide storage for the peers inside but does not ensure
% control of capabilities, deletion nor modification of the files.

\section{Architectural principles}

\subsection{Securing the nodes of a leafset}

%% Refering to the section in the paper "A Scalable Architecture for Highly Reliable Certification"
The first step to requesting a service is to acquire the set of nodes that
compose the leafset for a giben root key $K$. Supposing that $K$ is associated
with node $K_{ROOT}$, there remains a probability for $K_{ROOT}$ to be
malicious. $K_{ROOT}$ might lie and provide references to other malicious nodes
in order to collude against the requester, or it might deny any service by
remaining silet. Therefore, a simple request to $K_{ROOT}$ will not suffice to
acquire a reliable leafset associated with $K$.

Our solution for mitigating this issue is to use the DiversityTrustedRoute
algorithm~\cite{diversity_trusted_route}. DiversityTrustedRoute uses different
nodes as starting points in order to reach the same root node $K_{ROOT}$. The
diversity of the routing tables on each node guarantees a very high probability
of reaching root node $K_{ROOT}$ using different paths, and therefore of
entering the leafset of $K_{ROOT}$ via different nodes. This makes for a more
secure way of acquiring the leafset associated with a key $K$.

\subsection{Normal service request}

To find the nodes associated with a given service, node $A$ computes the hash
of the service name: $K_s = SHA(ServiceName)$. Let $S_{root} $ be the node that
is closest to $K_s$ in the DHT. $A$ uses DiversityTrustedRoute to acquire the
leafset of $S_{root}$. $A$ thus obtains access to the set $S$ of nodes that
process requests for service $ServiceName$. Let L be the number of nodes in a
leafset: $card(S) = L + 1$.

Once $A$ has acquired $S$, it proceeds to the inception of its service request
by sending a $RequestInit$ message to every node in $S$. A $RequestInit$
message contains a public key $A^{pub}$ of client $A$. In reply to such a
message, every node $S_i$ sends its own public key $S^{pub}_i$. In order to
avoid man-in-the-middle attack, all the ensuing communications between $A$ and
nodes that belong to $S$ will use a public/private key encryption scheme to
ensure that no other node can read the content of the messages.
% later the node will use his user private key & public key in this exchange

If $A$ recieves at least $\frac{L}{2} + 1$ answers from the nodes in $S$, then
$A$ considers that the transaction will proceed. Since $S$ is composed of
common nodes from the DHT, it is possible for some of these nodes to be
malicious. However, as explained in our evaluation of the quasi identification
protocol~\ref{sec:evaluation}, a situation where $S$ contains more than
$\frac{L}{2}$ malicious nodes is highly improbable.

A combination of network failures and/or malicious nodes that choose to remain
silent may prevent $A$ from receiving at least $\frac{L}{2} + 1$ answers. Since
$S$ retains the properties of Pastry's leafset, the numerical closeness of its
nodes in the DHT implies that they will very likely be geographically far on
the Internet. Therefore, the probability of $\frac{L}{2} + 1 $ simultaneous IP
routing failures or node failures, that is the probability for more than
$\frac{L}{2}$ answers to not reach $A$, is very close to zero. To account for
this type of situation, $A$ aborts the transaction if it has not received a
sufficient amount of identical answers after a timeout $\delta t$. this is a
very rare and highly improbable case, as shown by our evaluation
in~\ref{sec:evaluation}.

%%%%%%% ---- OLD, NOT APPLICABLE TODAY ----
%%%The general view of the system consists in a multi-layered network based in trusted rings.
%%The general view of the system consists in a double-layered network; a Trusted
%%ring of nodes nested inside a normal DHT, with multiple routing policies
%%depending in the protocol of differents services. The user registration,
%%sign-in, logout and password change operations respectively allow a node to
%%register an user identity, to identify himself with an existing user identity,
%%to remove your user session and to change the password used to sign-in.
%%
%%The system needs to have a \textit{trusted ring} maintained by periodical
%%checks of capacity of his members to remain in the trusted ring and a
%%reputation system to evaluate this. Also, similar to the
%%leafset concept in Pastry, each trusted node needs to maintain a
%%\textit{trustset}, wich basically consist in D numerically closest trusted
%%nodes with D/2 clockwise nodes, and D/2 counter-clockwise ones.
%%
%%The system used to build the trusted node infraestructure in the P2P networks
%%needs to regularly asses the ability of the nodes to be part of the trusted
%%ring.
%%
%%The figure shows a basic structure of the system. There are normal nodes and
%%trusted nodes. Every trusted nodes maintains a \textit{trustsets}.


We now describe our protocols based on the system model. 
%Figure 2 shows the information objects and
%their storage locations, with arrows for the abstract flow of the
%login procedure, Table I lists the terms used in the algorithms.
%A. Account Registration

\section{Account registration}
\includegraphics[width=14cm]{../img/registration_protocol_mockup.png}\\

To register a new user account ($U$), the node first
has to choose a \textit{username} and a \textit{password}.
%The \textit{username} should be unique in the network.
% The user checks if the username exists by sending a
% REGISTER(username, identity_file: [[c(user_keys_file), salt]).
% This operation use a accounted routing algorithm that uses only trusted
% nodes. When the register operation reaches the closest node to the username,
% it propagates a TRUSTSET_USERNAME_REGISTRATION operation. This operation sends a
% call to each node in the trustset of the node, wich then pass to do a council
% meeting. If the meeting results in favor, each of them sends a
% OK_USERNAME_REGISTRATION(user_identity_file_name) to node doing the REGISTER operation.
% 
% DETAILS OF THE REGISTER OPERATION
% DETAILS OF THE COUNCIL MEETING --> Explain before, in trusted node part 
% 

% key store file
Then, a key derivation process is issued to generate the user Private and
Public Keys. The
key derivation utilices a Salt ($U^{salt}$) and a Password ($U^{password}$) to
obtain the user's private and public Keys
($U^{priv}$ and $U^{pub}$).
The node  looks for the set $I$ set of nodes that will constitute the
identification service for the user $U$. To obtain the list of nodes that provides the user identification service for
the username $U^{username}$, the node $A$ computes its key $K$ such that $K =
SHA(U^{username})$. 

Then the node $A$ sends a request to every node $I_i$ in $I$ to register the
$U^{salt}$ and $U^{Pub}$ under the chosen  username  $U^{username}$. When the node
$A$ recieves at least $\frac{L}{2} + 1$ identical affirmative answers from
$I$ regarding the user registration, then $A$ assumes that the user was
actually registered.

%unique username
In case that the username was taken,
the node $A$ is prompted for a new username.


\section{Sign-in}

\subsection{User private key recovery}
\label{sec:private_key_recovery}
\includegraphics[width=14cm]{../img/login_protocol_mockup}\\

First, the node $A$ looks for the set $I$ set of nodes that will constitute the
identification service for the user $U$.
To obtain the list of nodes $I$ that provides the user identification service for
the username $U^{username}$, the node $A$ computes its key $K$ such that $K =
SHA(U^{username})$. 
Then the node $A$ sends a request to every node $I_i$ in $I$ to obtain the user
salt $U^{salt}$ needed to derive the user private key $U^{priv}$.
 When the node $A$ recieves at least $\frac{L}{2} + 1$ identical affirmative answers from
$I$ regarding the user salt, then $A$ assumes that the salt retrieved
corresponds to the one registered previously by the user ($U^{salt}$). Finally,
the node proccedes to derive the user private key $U^{priv}$ using his user password $U^{password}$.

\subsection{User identified service request}
\includegraphics[width=14cm]{../img/session_creation_protocol_mockup}\\

Before carrying out a transaction for a client $A$, $S$ proceeds to
verify the identity of the client from another set $I$ of nodes. At the end of
the intentification process, the objective is to return a session key to $A$
and to store the created session on the nodes that belong $C$.

% CHALLENGE, TODO: FIND A BETTER ONE
Each node in $S$ generates a random secret $S^{secret}_i$ wich is sent to the
client $A$. Then, client $A$ responds each request with the corresponding secret
encrypted with his user private key $U^{priv}$, generating
$E^{secret_i}_{U^{priv}}$. 
%The service $S$ send a $EncryptedSecretRequest$ to the client $A$, wich is
%responded with the 
% The service requires a encrypted secret from the client A. The node A
encrypts the secret using his private key obtained through
\ref{sec:private_key_recovery}.

Upon reception of the $E^{secret_i}_{U^{priv}}$ message from the client $A$, every node in $S$
starts looking for the set $I$ of nodes that will constitute the quasi
identification authority. To determine wich nodes belong to $I$, $S$ computes
its key $K$ such that $K = SHA(U^{username})$. $I_{root}$ is the node closest
to $K$ in the DHT, and the quasi identification authority $I = \{ I_1, I_2,
\cdots, I_{L+1}\}$ for the identification of $A$ is composed of $I_{root}$
and its leafset secured through DiversityTrustedRoute.

Then each node in $S$ sends a request to every node $I_i$ in $I$ asking for the Username public key $U^{pub}$. When a node
$S_i$ of $S$ recieves at least $\frac{L}{2} + 1$ identical answers from
$I$ regarding the $U^{pub}$, then $S_i$ assumes that the public key recieved
actually corresponds to the Username being identified. Each node $S_i$ in $S$
uses the $U^{pub}$ to decrypt $E^{secret_i}_{U^{priv}}$. If the result matches
the shared random secret $S^{secret}_i$, $S_i$ recognizes the node $A$ as the
user $U$.


\section{Logout}
%% OUTDATED
%%The system does not have something like a "session" to maintain; the only way
%%to identify an user is by his keys that are obtained by the identification
%%process.
%%
%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%
%% To log out from the system, the user does not have to interact
%%with the DHT or the storage system. Simply wiping her local
%%cache from application data and all key material restores the
%%pre-login state. If the user chose to remember the login on a
%%device, the corresponding device login information file FDL
%%can also be deleted from the storage.
%% A problem related to logging out is revoking remembered
%%credentials on another device, e. g., a user’s stolen phone. To
%%accomplish this, we first run the password change operation,
%%which locks out all devices with remembered logins, because
%%he key store key KKS changed (as well as the filename fKS ).
%%Next, we use the device mapping devmap to inform all devices
%%about the new key (and filename), except the device that is to
%%be revoked. To inform a device about the change, we update
%%the corresponding values in the device’s login information file
%% FDL which can be accessed from the device by using the
%%locally stored credentials.
%% Algorithm 4 describes this necessary extension. After run- the password change
%%operation, all devices that not ning shouldbe revoked and that have remembered
%%logins (and therefore are devmap) referenced in the device mapping are
%%processed. The device login information filename fDL and its key KDL are read,
%%and the new key store key KKS new and filename fKS new are written to the
%%device login information file FDL, encrypted under the device key KDL.
%%Finally, the modified devmap is saved back to the login information file FLI.
%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%
 

\section{Password Change}


%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%
%%Before the user can change the password, she must log in using her password to
%%obtain KLI . With this information, the password change can be accomplished
%%(see Algorithm 3): the user is asked for a new password and a new salt is
%%generated. The key-derivation function is used to generate a new key KLI new
%%for the login information file. Then, the content of the key-store file is
%%fetched and decrypted (with the old key). A new key KKS new is generated and
%%used for encrypting the key-store content again before it is saved to the
%%storage system, obtaining a new filename fKS new.
%%Finally, the login information file
%%is updated: fKS new, KKS new, the write credential KW as well as a new empty
%%device mapping devmapnew are encrypted with the new key KLI new.
%%  Together with the new salt, this ciphertext is written to the distributed
%%storage, using the reference fLI and the credential KW, to authenticate the
%%write operation. Lastly, the keys stored in the key store should be updated by
%%the application using our P2P protocol.  See Section VI-E for a discussion. At
%%this point, old device login information files can also be deleted from the
%%storage to reclaim space.
%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%

\chapter{Evaluation}

In this section we present a theoretical evaluation of
the authentication system.
%, as well as a set of simulations and performance
%results.

%%%Theoretical evaluation

We suppose in the following that the underlying
reputation system makes an error $\varepsilon$ when classifying a
node $X$ with a reputation $R(x) \geq \rho$, where $\rho \in [ 0 \cdots 1 ]$,
and $ \varepsilon = f ( \rho )$. In other words, classifying a node $X$ as
honest because its reputation is greater than $\rho$ has a
probability of error $\varepsilon$.
Let $n$ be the size of the Trusted Ring. The probability
to have $k$ misclassified nodes in the Trusted Ring, that
is $k$ malicious nodes is:

$$
P_{k_{malicious}} = \left(\!
                          \begin{array}{c}
                            n\\
                            k
                          \end{array}
                    \!\right)              
                    \varepsilon^{n-k} ( 1 - \varepsilon )^k
$$

Then, the probability to have at most $k$ malicious
nodes in a Trusted Ring of size $n$ is:

$$
P_{\leq k} = \sum^{k}_{i=1} \left(\!
                                \begin{array}{c}
                                    n\\
                                    k
                                  \end{array}
                            \!\right)              
                    \varepsilon^{n-i} ( 1 - \varepsilon )^i
$$

Therefore, the probability to have $k$ or more malicious
nodes in a Trusted Ring of size $n$ is:

$$
P_{\leq k} = \sum^{n}_{i=k} \left(\!
                                \begin{array}{c}
                                    n\\
                                    i
                                  \end{array}
                            \!\right)              
                    \varepsilon^{n-i} ( 1 - \varepsilon )^i
$$

The user identification fails when:
\begin{enumerate}
  \item The user cannot retrieve his own PKI from the \textit{trustset}.
  \item or when the public key of the user fails to be retrieved.
\end{enumerate}

These failures can happen when the \textit{trustsets} storing the PKI or the public
key have more malicious nodes than normal nodes.

The probability that a \textit{trustset} has half or more malicious nodes, assuming a maximum
classification error for the underlying reputation system
of $5\%$, is .% FILL HERE
%Hence the probability for having a fully erroneous trustset is theoretically possible, but
%practically infeasible.

Considering a maximum error rate of $5\%$ is a typical
value for a reputation system. In some cases it may be
over-estimated (for more details, please refer the results
obtained for the WTR reputation system\cite{wrt_reputation_system}). This
error hardly depends on the total number of malicious
nodes in the network, and decreases when the ratio
of malicious node decreases. The less malicious nodes
there are in the system, the easier it is to discriminate
against them.



\section{Forgotten passwords}

\section{Password-recovery mechanisms}
  - HUGE danger
  - Security questions
  - threshold-based secret sharing with delegate selection and encrypting
  shares with passwords



%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%
An important part of password-based logins is the possi-
 bility for users to recover their accounts if they forget their
 passwords. We refer to this as a password recovery mechanism.
 The goal of a password recovery mechanism is to provide a
 secondary way of authenticating the user. There are a number
 of password recovery mechanisms used in practice. In our
 experience, three of the most common ones are password
 hints, security questions, and e-mail based recovery. Other

approaches (beyond the scope of this paper) include vouching
for identity by social contacts [21], or using trusted devices.
 Password hints means that the user may enter a hint at
the same time as she sets this password. The hint will be
displayed to her if she forgets her password, and should be
selected such that it helps her recall her password, but does
not make it significantly easier for someone else to guess it.
The hint is not truly a secondary authentication mechanism,
but rather a means to recovering the original password-based
authentication mechanism. A basic version of password hints
would be straightforward to implement in our system: the
hint can be stored in plaintext in the login information file.
Security questions and e-mail based password recovery are
more complex to adapt. We described their implementation in
detail after listing requirements.
 As in Section IV for the login procedure, we define a set of
functional requirements for password recovery, based on the
ISO 27002 standard [19] as follows. We also augment the list
with requirements of our own (preceded by a star).
establish methods to verify the identity of a user prior to
•allowing the user to choose a new password
communicate with those affected by or involved with
 - recovery security incidents
 - have procedures to allow recovery and restoration of
business operations and availability of information in a
 time-scaled manner
a legitimate user should be able to recover lost (forgotten)
 - or broken (device’s) keys
 - the recovery procedure should allow a user to set a new
 password, not reveal the old password
 - the process of recovery should be easy to use
 - sensitive information for recovery should be kept secret
Our protocols support these requirements. The sole exception
is that if a password is reset via security questions alone, the
system would not “communicate with those affected” (e.g.,
send an e-mail notification that the password had been reset,
as is common in centralized services). We remark that the
last item is a property many centralizedstronger than systems
provide. In our system, no one learns the answers to a user’s
security questions. We consider this to be important, since
many systems use similar security questions.
 The operations described in this section imply minor addi-
tions to the protocols of Section IV, i. e., invoking the update
procedures after each password change (to sustain transaction
safety, the updates have to be included in the final write
operation of the password change operation).
A. Security Questions
 Security questions is a password recovery technique that
relies on answers to questions the user is asked during regis-
tration. The answers should be such that they cannot be easily
guessed or researched by an attacker, but still stable over
time, memorable, and definite [22]. Rabkin [23] underlines
the importance to choose good questions especially in the era
of social networks. Frykholm and Juels [12] discuss a related
technique that is similar to our adaption of this scheme.
%%%%%%%%%%%%%   Peerson Passwords in P2P networks %%%%%%%%%%%%%
 

\section{Password Change}

