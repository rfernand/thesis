Existing systems for the user identification in P2P networks only consider the
use of preshared keys to identificate the user in the network. While that can
be easily implemented, does not provide to the users the flexibility that a
username-password based identification provides when using different devices to
log in in the system. As the user needs to transfer manually his keys from one
device to another, there are many security issues when they are handled without
care or the devices (like a cellphone) are lost. 

The use of a username and a password means that the user keys needs to: a) be
secured inside the identification system or b) be derived from information
stored in the identification system. Between  the two options, the first one
needs a trusted storing scheme with additional use of encryption to secure the
private keys. In the other hand deriving the user private keys let us build the
identification system with the same desired properties without adding
additional complexity.

To handle the user keys without compromising the users identity, aditional
security layers needs to be placed inside the P2P network.

To secure the stored keys, the proposed system uses encryption, indirection and
rings of trust inside the network. The system goal is to offer a secure mean to
identify an user using only his username/password knowledge taking in
consideration the precense of bizantine nodes.

As shown in \cite{the_sybil_attack}, it is impossible to get a 100\% reliable
system over a DHT where malicious nodes are present. The goal of our approach
is to reduce drastically the probability of a malicious node to impersonate
another user using the identification system.

While the probability can always exist, it should be highly unlikely to happen
if we consider a probability of the order of $10^{-14}$.

\section{Building blocks and notation}

For simplicity, we assume in the following that the underlyng DHT is
Pastry~\cite{pastry} seen in the section~\ref{sec:pastry}. We suppose that
every node in the DHT self-generates its own pair of public and privates keys
($X^{pub}$, $X^{priv}$) to be used with an asymmetrical encryption
algorithm~\cite{asymmetrical_encryption_algorithm}. The size of the keys used
in the whole system is both fixed and large enough to make it computationally
infeasible to decrypt an information without knowing the corresponging private
keys. We will assume that an User is identified by the criptographic proof of
his private key. 

SHA stands for the Secure Hash Algorithm One (SHA-1 - 160 bits hash). We also
assume that all communications among nodes are made using the TCP protocol, and
that all transmissions errors are handled at the transport level.

A simple storage system is needed.
%% TODO:
%The \textit{trustsets} are in charge of the storage of the user keys that are
%used to identify an user in the system. The system needs a PUT(key,
%file) operation that stores the file in the closest trusted node based in the
%routing algorithm and a GET(key) operation that retrieves the stored file.


%%The identification system needs to use 


%% -- THIS IS NOT NECESSARY FOR THE IDENTIFICATION SYSTEM YET IT CAN BE USEFULL --
% Our final assumption is that the underlying operating system of every node which
%participates to the DHT is running the Network Time Protocol. Thus, we consider
%that every node has a good global time, wiuth a small deviation from the
%Coordinated Universal Time (UTC)

%\section{Securing  P2P networks}

%% TODO: Eval where to put this part about reputation systems

It assumes a reputation system in the overlay structure with the following properties:
\begin{enumerate}
  \item Every node $X$ has an associated reputation value $R(X)$
  which represents the probability that $X$ is an honest node.
  \item $R(X)$ is computed using the recommendations emitted
  by nodes that have completed a transaction with $X$. Bad
  recommendations have a stronger effect on $R(X)$ than
  good ones. It should be more difficult for node to
  increase its reputation value than to decrease it.
  \item For every node $X$, $R(X)$ is highly available in the DHT.
\end{enumerate}

The reputation value $R(X)$ is the probability that node $X$ will
be honest in the future. This reputation value is computed
according to a list of recommendations emitted by nodes that
have already carried out transactions with $X$.
After each transaction, a node emits a recommendation
about its peer. A node may lie: it may emit negative
recommendations about a peer that behaves correctly, or
positive recommendations about a malicious peer. Several nodes
may collude to increase or decrease the reputation value of
another node. These problems generate a deviation between
the computed reputation of the node and its real behaviour. It is
considered that this deviation depends on the function used to
compute the reputation value and on the percentage of malicious
nodes within the system.

To avoid nodes that lie about a reputation value, it considers a reputation
system that computes the reputation of nodes concurrently on different nodes,
as seen before in WTR~\ref{sec:wtr}.
They decide individually if that node is reputable or not, using a voting
scheme in case of disagreement. On the whole, assuming that there is a smaller
percentage of malicious nodes in the network, the result avoids
false statements about reputation.

To maintain the same nomenclature seen in CORPS~\ref{sec:corps}, in all the following sections,
we call a node $n_i \in TS$ a trusted node, even if there still remains a
probability that this node's actual reputation is smaller than the threshold
$\rho$.
